#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
mod indented {
    use syn::*;
    use crate::types::parse_error;
    pub fn parse_at_level_fn<L: IndentLevel>(
        input: parse::ParseStream,
        mut f: impl FnMut() -> Result<()>,
    ) -> Result<()> {
        input.parse::<L>()?;
        f()?;
        loop {
            match input.fork().parse::<L>() {
                Ok(_) => {
                    input.parse::<L>()?;
                    f()?;
                }
                _ => break,
            }
        }
        Ok(())
    }
    pub fn parse_at_level<I: IndentLevel, T: ParseIndented<I>>(
        input: parse::ParseStream,
    ) -> Result<Vec<T>> {
        input.parse::<I>()?;
        let mut out = <[_]>::into_vec(
            ::alloc::boxed::box_new([T::parse_indented(input)?]),
        );
        loop {
            match input.fork().parse::<I>() {
                Ok(_) => {
                    input.parse::<I>()?;
                    out.push(T::parse_indented(input)?);
                }
                _ => break,
            }
        }
        Ok(out)
    }
    struct YamlListItem<T>(T);
    impl<L: IndentLevel, T: ParseIndented<L>> ParseIndented<L> for YamlListItem<T> {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            input.parse::<::syn::token::Sub>()?;
            Ok(YamlListItem(T::parse_indented(input)?))
        }
    }
    pub fn parse_yaml_array<I: IndentLevel, T: ParseIndented<I::Next>>(
        input: parse::ParseStream,
    ) -> Result<Vec<T>> {
        let out: Vec<YamlListItem<T>> = parse_at_level::<I::Next, _>(input)?;
        Ok(out.into_iter().map(|YamlListItem(t)| t).collect())
    }
    pub struct IndentedToken<T: parse::Parse>(pub T);
    impl<L: IndentLevel, T: parse::Parse> ParseIndented<L> for IndentedToken<T> {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(IndentedToken(input.parse()?))
        }
    }
    pub fn parse_indented_token<L: IndentLevel, O: parse::Parse>(
        input: parse::ParseStream,
    ) -> Result<O> {
        input.parse()
    }
    pub fn parse_yaml_token_array<I: IndentLevel, T: parse::Parse>(
        input: parse::ParseStream,
    ) -> Result<Vec<T>> {
        let out = parse_yaml_array::<I, IndentedToken<T>>(input)?;
        Ok(out.into_iter().map(|IndentedToken(t)| t).collect())
    }
    pub trait ParseIndented<L: IndentLevel>: Sized {
        fn parse_indented(input: parse::ParseStream) -> Result<Self>;
    }
    pub fn parse_indented<L: IndentLevel, O: ParseIndented<L>>(
        input: parse::ParseStream,
    ) -> Result<O> {
        O::parse_indented(input)
    }
    pub fn parse_indented_next_level<L: IndentLevel, O: ParseIndented<L::Next>>(
        input: parse::ParseStream,
    ) -> Result<O> {
        O::parse_indented(input)
    }
    pub struct Indent<const LEVEL: usize>;
    impl<const LEVEL: usize> parse::Parse for Indent<LEVEL> {
        fn parse(input: parse::ParseStream) -> Result<Self> {
            if LEVEL > 16 {
                Err(syn::Error::new(input.span(), "Indent level max is 16"))?;
            }
            let id = input.parse::<syn::Ident>()?;
            let valid = id.to_string().starts_with("__indent_");
            if !valid {
                Err(syn::Error::new(input.span(), "expected indent"))?
            }
            let l: usize = id.to_string()[9..].parse().unwrap();
            if l != LEVEL {
                let msg = ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Wrong indent level (expected {0}, got {1})",
                            LEVEL,
                            l,
                        ),
                    );
                    res
                });
                Err(syn::Error::new(input.span(), msg))?
            }
            Ok(Indent)
        }
    }
    pub trait IndentLevel: parse::Parse {
        type Next: IndentLevel;
        fn get_level() -> usize;
    }
    impl IndentLevel for Indent<0> {
        type Next = Indent<1>;
        fn get_level() -> usize {
            0
        }
    }
    impl IndentLevel for Indent<1> {
        type Next = Indent<2>;
        fn get_level() -> usize {
            1
        }
    }
    impl IndentLevel for Indent<2> {
        type Next = Indent<3>;
        fn get_level() -> usize {
            2
        }
    }
    impl IndentLevel for Indent<3> {
        type Next = Indent<4>;
        fn get_level() -> usize {
            3
        }
    }
    impl IndentLevel for Indent<4> {
        type Next = Indent<5>;
        fn get_level() -> usize {
            4
        }
    }
    impl IndentLevel for Indent<5> {
        type Next = Indent<6>;
        fn get_level() -> usize {
            5
        }
    }
    impl IndentLevel for Indent<6> {
        type Next = Indent<7>;
        fn get_level() -> usize {
            6
        }
    }
    impl IndentLevel for Indent<7> {
        type Next = Indent<8>;
        fn get_level() -> usize {
            7
        }
    }
    impl IndentLevel for Indent<8> {
        type Next = Indent<9>;
        fn get_level() -> usize {
            8
        }
    }
    impl IndentLevel for Indent<9> {
        type Next = Indent<10>;
        fn get_level() -> usize {
            9
        }
    }
    impl IndentLevel for Indent<10> {
        type Next = Indent<11>;
        fn get_level() -> usize {
            10
        }
    }
    impl IndentLevel for Indent<11> {
        type Next = Indent<12>;
        fn get_level() -> usize {
            11
        }
    }
    impl IndentLevel for Indent<12> {
        type Next = Indent<13>;
        fn get_level() -> usize {
            12
        }
    }
    impl IndentLevel for Indent<13> {
        type Next = Indent<14>;
        fn get_level() -> usize {
            13
        }
    }
    impl IndentLevel for Indent<14> {
        type Next = Indent<15>;
        fn get_level() -> usize {
            14
        }
    }
    impl IndentLevel for Indent<15> {
        type Next = Indent<16>;
        fn get_level() -> usize {
            15
        }
    }
    impl IndentLevel for Indent<16> {
        type Next = Indent<17>;
        fn get_level() -> usize {
            16
        }
    }
    impl IndentLevel for Indent<17> {
        type Next = Indent<0>;
        fn get_level() -> usize {
            1000
        }
    }
    pub fn create_indented_tokenstream(
        tokens: proc_macro::TokenStream,
    ) -> proc_macro::TokenStream {
        let mut iter = tokens.into_iter();
        let group = match iter.next() {
            Some(proc_macro::TokenTree::Group(g)) => g,
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("Expected a single Group token"),
                );
            }
        };
        let source = group.span().source_text().expect("source_text unavailable");
        let inner_tokens = group.stream();
        let mut result = Vec::new();
        let mut current_pos = 0;
        for token in inner_tokens {
            let text = match &token {
                proc_macro::TokenTree::Punct(p) if p.as_char() == '\'' => {
                    Some("'".to_string())
                }
                proc_macro::TokenTree::Ident(i) => Some(i.to_string()),
                _ => token.span().source_text(),
            };
            if let Some(text) = text {
                if let Some(pos) = source[current_pos..].find(&text) {
                    let abs_pos = current_pos + pos;
                    let prefix = &source[current_pos..abs_pos];
                    if let Some(id) = parse_indent(prefix, &token) {
                        result.push(id.into());
                    }
                    result.push(token);
                    current_pos = abs_pos + text.len();
                }
            }
        }
        result.into_iter().collect()
    }
    fn parse_indent(
        s: &str,
        token: &proc_macro::TokenTree,
    ) -> Option<proc_macro::Ident> {
        let span = token.span();
        let orig = s;
        let mut s = s;
        if s.chars().next() == Some('{') {
            s = &s[1..];
        }
        let mut seen = false;
        loop {
            match s.find(|c| c == '\n') {
                Some(pos) => {
                    seen = true;
                    s = &s[pos + 1..];
                }
                None => break,
            }
        }
        if !seen {
            return None;
        }
        let spaces = s.chars().take_while(|&c| c == ' ').count();
        if spaces % 2 == 1 {
            {
                ::core::panicking::panic_fmt(
                    format_args!("indent spaces should be multiple of 2: {0:?}", orig),
                );
            };
        }
        let s = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(format_args!("__indent_{0}", spaces >> 1));
            res
        });
        let ss = s.as_str();
        return Some(proc_macro::Ident::new(ss, span));
    }
}
mod propsets {
    use std::{collections::HashMap, fmt::Debug};
    pub struct DynStruct<Set: PropSet>(HashMap<&'static str, Set>);
    #[automatically_derived]
    impl<Set: ::core::fmt::Debug + PropSet> ::core::fmt::Debug for DynStruct<Set> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "DynStruct", &&self.0)
        }
    }
    #[automatically_derived]
    impl<Set: ::core::clone::Clone + PropSet> ::core::clone::Clone for DynStruct<Set> {
        #[inline]
        fn clone(&self) -> DynStruct<Set> {
            DynStruct(::core::clone::Clone::clone(&self.0))
        }
    }
    impl<Set: PropSet> DynStruct<Set> {
        pub fn new() -> Self {
            DynStruct(HashMap::new())
        }
        pub fn has(&self, label: &str) -> bool {
            self.0.contains_key(label)
        }
        pub fn get<P: PropOf<Set>>(&self) -> Option<&P> {
            self.0.get(P::LABEL).map(P::downcast_ref)
        }
        pub fn insert<P: PropOf<Set>>(&mut self, val: P) -> Option<P> {
            self.0.insert(P::LABEL, val.into()).map(P::downcast)
        }
        pub fn insert_dyn(&mut self, prop: Set) -> Option<Set> {
            self.0.insert(prop.label(), prop)
        }
        pub fn iter(&self) -> impl Iterator<Item = (&str, Set)> {
            self.0.clone().into_iter().map(|(k, v)| { (k, v) })
        }
        pub fn len(&self) -> usize {
            self.0.len()
        }
    }
    pub trait IsDynProp {
        type TYPE: 'static + Clone;
        const LABEL: &'static str;
    }
    pub trait PropSet: Clone + Debug {
        const PROPS: &[&str];
        fn has_prop(label: &str) -> bool;
        fn label(&self) -> &'static str;
    }
    pub trait PropOf<Set: PropSet>: IsDynProp + Into<Set> {
        fn downcast(set: Set) -> Self;
        fn downcast_ref(set: &Set) -> &Self;
    }
    pub(crate) use define_prop;
    pub(crate) use define_prop_set;
}
mod types {
    use std::collections::HashMap;
    use syn::*;
    pub struct YamlDoc(pub YamlContexts, pub YamlAccounts);
    #[automatically_derived]
    impl ::core::fmt::Debug for YamlDoc {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field2_finish(
                f,
                "YamlDoc",
                &self.0,
                &&self.1,
            )
        }
    }
    pub struct YamlContexts(pub KeyedVec<Vec<ContextProp>>);
    #[automatically_derived]
    impl ::core::fmt::Debug for YamlContexts {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "YamlContexts",
                &&self.0,
            )
        }
    }
    pub type YamlAccounts = KeyedVec<DynStruct<ParseAccountProps>>;
    use crate::propsets::*;
    pub struct Space(pub LitInt);
    #[automatically_derived]
    impl ::core::fmt::Debug for Space {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Space", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Space {
        #[inline]
        fn clone(&self) -> Space {
            Space(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for Space {
        type TYPE = LitInt;
        const LABEL: &'static str = "space";
    }
    impl Space {
        pub fn unwrap(self) -> LitInt {
            self.0
        }
    }
    pub struct Boxed(pub LitBool);
    #[automatically_derived]
    impl ::core::fmt::Debug for Boxed {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Boxed", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Boxed {
        #[inline]
        fn clone(&self) -> Boxed {
            Boxed(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for Boxed {
        type TYPE = LitBool;
        const LABEL: &'static str = "boxed";
    }
    impl Boxed {
        pub fn unwrap(self) -> LitBool {
            self.0
        }
    }
    pub struct Mut(pub LitBool);
    #[automatically_derived]
    impl ::core::fmt::Debug for Mut {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Mut", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mut {
        #[inline]
        fn clone(&self) -> Mut {
            Mut(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for Mut {
        type TYPE = LitBool;
        const LABEL: &'static str = "mut";
    }
    impl Mut {
        pub fn unwrap(self) -> LitBool {
            self.0
        }
    }
    pub struct Constraints(pub Vec<LitStr>);
    #[automatically_derived]
    impl ::core::fmt::Debug for Constraints {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Constraints", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Constraints {
        #[inline]
        fn clone(&self) -> Constraints {
            Constraints(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for Constraints {
        type TYPE = Vec<LitStr>;
        const LABEL: &'static str = "constraints";
    }
    impl Constraints {
        pub fn unwrap(self) -> Vec<LitStr> {
            self.0
        }
    }
    pub struct AccountType(pub syn::Path);
    #[automatically_derived]
    impl ::core::fmt::Debug for AccountType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "AccountType", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AccountType {
        #[inline]
        fn clone(&self) -> AccountType {
            AccountType(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for AccountType {
        type TYPE = syn::Path;
        const LABEL: &'static str = "type";
    }
    impl AccountType {
        pub fn unwrap(self) -> syn::Path {
            self.0
        }
    }
    pub struct Seeds(pub ExprArray);
    #[automatically_derived]
    impl ::core::fmt::Debug for Seeds {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Seeds", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Seeds {
        #[inline]
        fn clone(&self) -> Seeds {
            Seeds(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for Seeds {
        type TYPE = ExprArray;
        const LABEL: &'static str = "seeds";
    }
    impl Seeds {
        pub fn unwrap(self) -> ExprArray {
            self.0
        }
    }
    pub struct TokenMint(pub Ident);
    #[automatically_derived]
    impl ::core::fmt::Debug for TokenMint {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "TokenMint", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TokenMint {
        #[inline]
        fn clone(&self) -> TokenMint {
            TokenMint(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for TokenMint {
        type TYPE = Ident;
        const LABEL: &'static str = "token :: mint";
    }
    impl TokenMint {
        pub fn unwrap(self) -> Ident {
            self.0
        }
    }
    pub struct TokenAuthority(pub Ident);
    #[automatically_derived]
    impl ::core::fmt::Debug for TokenAuthority {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "TokenAuthority",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TokenAuthority {
        #[inline]
        fn clone(&self) -> TokenAuthority {
            TokenAuthority(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for TokenAuthority {
        type TYPE = Ident;
        const LABEL: &'static str = "token :: authority";
    }
    impl TokenAuthority {
        pub fn unwrap(self) -> Ident {
            self.0
        }
    }
    pub struct RealInit(pub ());
    #[automatically_derived]
    impl ::core::fmt::Debug for RealInit {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "RealInit", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RealInit {
        #[inline]
        fn clone(&self) -> RealInit {
            RealInit(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for RealInit {
        type TYPE = ();
        const LABEL: &'static str = "init";
    }
    impl RealInit {
        pub fn unwrap(self) -> () {
            self.0
        }
    }
    pub enum RealAccountPropsSansInit {
        Boxed(Boxed),
        Space(Space),
        Constraints(Constraints),
        Mut(Mut),
        AccountType(AccountType),
        Seeds(Seeds),
        TokenMint(TokenMint),
        TokenAuthority(TokenAuthority),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RealAccountPropsSansInit {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                RealAccountPropsSansInit::Boxed(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boxed",
                        &__self_0,
                    )
                }
                RealAccountPropsSansInit::Space(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Space",
                        &__self_0,
                    )
                }
                RealAccountPropsSansInit::Constraints(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Constraints",
                        &__self_0,
                    )
                }
                RealAccountPropsSansInit::Mut(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mut",
                        &__self_0,
                    )
                }
                RealAccountPropsSansInit::AccountType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AccountType",
                        &__self_0,
                    )
                }
                RealAccountPropsSansInit::Seeds(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Seeds",
                        &__self_0,
                    )
                }
                RealAccountPropsSansInit::TokenMint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TokenMint",
                        &__self_0,
                    )
                }
                RealAccountPropsSansInit::TokenAuthority(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TokenAuthority",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RealAccountPropsSansInit {
        #[inline]
        fn clone(&self) -> RealAccountPropsSansInit {
            match self {
                RealAccountPropsSansInit::Boxed(__self_0) => {
                    RealAccountPropsSansInit::Boxed(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                RealAccountPropsSansInit::Space(__self_0) => {
                    RealAccountPropsSansInit::Space(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                RealAccountPropsSansInit::Constraints(__self_0) => {
                    RealAccountPropsSansInit::Constraints(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                RealAccountPropsSansInit::Mut(__self_0) => {
                    RealAccountPropsSansInit::Mut(::core::clone::Clone::clone(__self_0))
                }
                RealAccountPropsSansInit::AccountType(__self_0) => {
                    RealAccountPropsSansInit::AccountType(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                RealAccountPropsSansInit::Seeds(__self_0) => {
                    RealAccountPropsSansInit::Seeds(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                RealAccountPropsSansInit::TokenMint(__self_0) => {
                    RealAccountPropsSansInit::TokenMint(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                RealAccountPropsSansInit::TokenAuthority(__self_0) => {
                    RealAccountPropsSansInit::TokenAuthority(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    impl PropOf<RealAccountPropsSansInit> for Boxed {
        fn downcast_ref(set: &RealAccountPropsSansInit) -> &Self {
            match set {
                RealAccountPropsSansInit::Boxed(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountPropsSansInit) -> Self {
            match set {
                RealAccountPropsSansInit::Boxed(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountPropsSansInit> for Space {
        fn downcast_ref(set: &RealAccountPropsSansInit) -> &Self {
            match set {
                RealAccountPropsSansInit::Space(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountPropsSansInit) -> Self {
            match set {
                RealAccountPropsSansInit::Space(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountPropsSansInit> for Constraints {
        fn downcast_ref(set: &RealAccountPropsSansInit) -> &Self {
            match set {
                RealAccountPropsSansInit::Constraints(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountPropsSansInit) -> Self {
            match set {
                RealAccountPropsSansInit::Constraints(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountPropsSansInit> for Mut {
        fn downcast_ref(set: &RealAccountPropsSansInit) -> &Self {
            match set {
                RealAccountPropsSansInit::Mut(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountPropsSansInit) -> Self {
            match set {
                RealAccountPropsSansInit::Mut(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountPropsSansInit> for AccountType {
        fn downcast_ref(set: &RealAccountPropsSansInit) -> &Self {
            match set {
                RealAccountPropsSansInit::AccountType(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountPropsSansInit) -> Self {
            match set {
                RealAccountPropsSansInit::AccountType(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountPropsSansInit> for Seeds {
        fn downcast_ref(set: &RealAccountPropsSansInit) -> &Self {
            match set {
                RealAccountPropsSansInit::Seeds(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountPropsSansInit) -> Self {
            match set {
                RealAccountPropsSansInit::Seeds(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountPropsSansInit> for TokenMint {
        fn downcast_ref(set: &RealAccountPropsSansInit) -> &Self {
            match set {
                RealAccountPropsSansInit::TokenMint(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountPropsSansInit) -> Self {
            match set {
                RealAccountPropsSansInit::TokenMint(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountPropsSansInit> for TokenAuthority {
        fn downcast_ref(set: &RealAccountPropsSansInit) -> &Self {
            match set {
                RealAccountPropsSansInit::TokenAuthority(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountPropsSansInit) -> Self {
            match set {
                RealAccountPropsSansInit::TokenAuthority(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropSet for RealAccountPropsSansInit {
        const PROPS: &[&str] = &[
            Boxed::LABEL,
            Space::LABEL,
            Constraints::LABEL,
            Mut::LABEL,
            AccountType::LABEL,
            Seeds::LABEL,
            TokenMint::LABEL,
            TokenAuthority::LABEL,
        ];
        fn has_prop(label: &str) -> bool {
            label == Boxed::LABEL || label == Space::LABEL || label == Constraints::LABEL
                || label == Mut::LABEL || label == AccountType::LABEL
                || label == Seeds::LABEL || label == TokenMint::LABEL
                || label == TokenAuthority::LABEL
        }
        fn label(&self) -> &'static str {
            match self {
                RealAccountPropsSansInit::Boxed(_) => Boxed::LABEL,
                RealAccountPropsSansInit::Space(_) => Space::LABEL,
                RealAccountPropsSansInit::Constraints(_) => Constraints::LABEL,
                RealAccountPropsSansInit::Mut(_) => Mut::LABEL,
                RealAccountPropsSansInit::AccountType(_) => AccountType::LABEL,
                RealAccountPropsSansInit::Seeds(_) => Seeds::LABEL,
                RealAccountPropsSansInit::TokenMint(_) => TokenMint::LABEL,
                RealAccountPropsSansInit::TokenAuthority(_) => TokenAuthority::LABEL,
            }
        }
    }
    impl Into<RealAccountPropsSansInit> for Boxed {
        fn into(self) -> RealAccountPropsSansInit {
            RealAccountPropsSansInit::Boxed(self)
        }
    }
    impl Into<RealAccountPropsSansInit> for Space {
        fn into(self) -> RealAccountPropsSansInit {
            RealAccountPropsSansInit::Space(self)
        }
    }
    impl Into<RealAccountPropsSansInit> for Constraints {
        fn into(self) -> RealAccountPropsSansInit {
            RealAccountPropsSansInit::Constraints(self)
        }
    }
    impl Into<RealAccountPropsSansInit> for Mut {
        fn into(self) -> RealAccountPropsSansInit {
            RealAccountPropsSansInit::Mut(self)
        }
    }
    impl Into<RealAccountPropsSansInit> for AccountType {
        fn into(self) -> RealAccountPropsSansInit {
            RealAccountPropsSansInit::AccountType(self)
        }
    }
    impl Into<RealAccountPropsSansInit> for Seeds {
        fn into(self) -> RealAccountPropsSansInit {
            RealAccountPropsSansInit::Seeds(self)
        }
    }
    impl Into<RealAccountPropsSansInit> for TokenMint {
        fn into(self) -> RealAccountPropsSansInit {
            RealAccountPropsSansInit::TokenMint(self)
        }
    }
    impl Into<RealAccountPropsSansInit> for TokenAuthority {
        fn into(self) -> RealAccountPropsSansInit {
            RealAccountPropsSansInit::TokenAuthority(self)
        }
    }
    #[allow(unused_imports)]
    pub(crate) use impl_prop_dispatch_RealAccountPropsSansInit;
    pub enum RealAccountProps {
        Boxed(Boxed),
        Space(Space),
        Constraints(Constraints),
        Mut(Mut),
        AccountType(AccountType),
        Seeds(Seeds),
        TokenMint(TokenMint),
        TokenAuthority(TokenAuthority),
        RealInit(RealInit),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RealAccountProps {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                RealAccountProps::Boxed(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boxed",
                        &__self_0,
                    )
                }
                RealAccountProps::Space(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Space",
                        &__self_0,
                    )
                }
                RealAccountProps::Constraints(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Constraints",
                        &__self_0,
                    )
                }
                RealAccountProps::Mut(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mut",
                        &__self_0,
                    )
                }
                RealAccountProps::AccountType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AccountType",
                        &__self_0,
                    )
                }
                RealAccountProps::Seeds(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Seeds",
                        &__self_0,
                    )
                }
                RealAccountProps::TokenMint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TokenMint",
                        &__self_0,
                    )
                }
                RealAccountProps::TokenAuthority(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TokenAuthority",
                        &__self_0,
                    )
                }
                RealAccountProps::RealInit(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RealInit",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RealAccountProps {
        #[inline]
        fn clone(&self) -> RealAccountProps {
            match self {
                RealAccountProps::Boxed(__self_0) => {
                    RealAccountProps::Boxed(::core::clone::Clone::clone(__self_0))
                }
                RealAccountProps::Space(__self_0) => {
                    RealAccountProps::Space(::core::clone::Clone::clone(__self_0))
                }
                RealAccountProps::Constraints(__self_0) => {
                    RealAccountProps::Constraints(::core::clone::Clone::clone(__self_0))
                }
                RealAccountProps::Mut(__self_0) => {
                    RealAccountProps::Mut(::core::clone::Clone::clone(__self_0))
                }
                RealAccountProps::AccountType(__self_0) => {
                    RealAccountProps::AccountType(::core::clone::Clone::clone(__self_0))
                }
                RealAccountProps::Seeds(__self_0) => {
                    RealAccountProps::Seeds(::core::clone::Clone::clone(__self_0))
                }
                RealAccountProps::TokenMint(__self_0) => {
                    RealAccountProps::TokenMint(::core::clone::Clone::clone(__self_0))
                }
                RealAccountProps::TokenAuthority(__self_0) => {
                    RealAccountProps::TokenAuthority(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                RealAccountProps::RealInit(__self_0) => {
                    RealAccountProps::RealInit(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for Boxed {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::Boxed(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::Boxed(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for Space {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::Space(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::Space(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for Constraints {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::Constraints(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::Constraints(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for Mut {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::Mut(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::Mut(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for AccountType {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::AccountType(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::AccountType(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for Seeds {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::Seeds(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::Seeds(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for TokenMint {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::TokenMint(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::TokenMint(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for TokenAuthority {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::TokenAuthority(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::TokenAuthority(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<RealAccountProps> for RealInit {
        fn downcast_ref(set: &RealAccountProps) -> &Self {
            match set {
                RealAccountProps::RealInit(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: RealAccountProps) -> Self {
            match set {
                RealAccountProps::RealInit(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropSet for RealAccountProps {
        const PROPS: &[&str] = &[
            Boxed::LABEL,
            Space::LABEL,
            Constraints::LABEL,
            Mut::LABEL,
            AccountType::LABEL,
            Seeds::LABEL,
            TokenMint::LABEL,
            TokenAuthority::LABEL,
            RealInit::LABEL,
        ];
        fn has_prop(label: &str) -> bool {
            label == Boxed::LABEL || label == Space::LABEL || label == Constraints::LABEL
                || label == Mut::LABEL || label == AccountType::LABEL
                || label == Seeds::LABEL || label == TokenMint::LABEL
                || label == TokenAuthority::LABEL || label == RealInit::LABEL
        }
        fn label(&self) -> &'static str {
            match self {
                RealAccountProps::Boxed(_) => Boxed::LABEL,
                RealAccountProps::Space(_) => Space::LABEL,
                RealAccountProps::Constraints(_) => Constraints::LABEL,
                RealAccountProps::Mut(_) => Mut::LABEL,
                RealAccountProps::AccountType(_) => AccountType::LABEL,
                RealAccountProps::Seeds(_) => Seeds::LABEL,
                RealAccountProps::TokenMint(_) => TokenMint::LABEL,
                RealAccountProps::TokenAuthority(_) => TokenAuthority::LABEL,
                RealAccountProps::RealInit(_) => RealInit::LABEL,
            }
        }
    }
    impl Into<RealAccountProps> for Boxed {
        fn into(self) -> RealAccountProps {
            RealAccountProps::Boxed(self)
        }
    }
    impl Into<RealAccountProps> for Space {
        fn into(self) -> RealAccountProps {
            RealAccountProps::Space(self)
        }
    }
    impl Into<RealAccountProps> for Constraints {
        fn into(self) -> RealAccountProps {
            RealAccountProps::Constraints(self)
        }
    }
    impl Into<RealAccountProps> for Mut {
        fn into(self) -> RealAccountProps {
            RealAccountProps::Mut(self)
        }
    }
    impl Into<RealAccountProps> for AccountType {
        fn into(self) -> RealAccountProps {
            RealAccountProps::AccountType(self)
        }
    }
    impl Into<RealAccountProps> for Seeds {
        fn into(self) -> RealAccountProps {
            RealAccountProps::Seeds(self)
        }
    }
    impl Into<RealAccountProps> for TokenMint {
        fn into(self) -> RealAccountProps {
            RealAccountProps::TokenMint(self)
        }
    }
    impl Into<RealAccountProps> for TokenAuthority {
        fn into(self) -> RealAccountProps {
            RealAccountProps::TokenAuthority(self)
        }
    }
    impl Into<RealAccountProps> for RealInit {
        fn into(self) -> RealAccountProps {
            RealAccountProps::RealInit(self)
        }
    }
    #[allow(unused_imports)]
    pub(crate) use impl_prop_dispatch_RealAccountProps;
    pub struct Depends(pub Vec<Ident>);
    #[automatically_derived]
    impl ::core::fmt::Debug for Depends {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Depends", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Depends {
        #[inline]
        fn clone(&self) -> Depends {
            Depends(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for Depends {
        type TYPE = Vec<Ident>;
        const LABEL: &'static str = "depends";
    }
    impl Depends {
        pub fn unwrap(self) -> Vec<Ident> {
            self.0
        }
    }
    pub struct Init(pub DynStruct<RealAccountPropsSansInit>);
    #[automatically_derived]
    impl ::core::fmt::Debug for Init {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Init", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Init {
        #[inline]
        fn clone(&self) -> Init {
            Init(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for Init {
        type TYPE = DynStruct<RealAccountPropsSansInit>;
        const LABEL: &'static str = "init";
    }
    impl Init {
        pub fn unwrap(self) -> DynStruct<RealAccountPropsSansInit> {
            self.0
        }
    }
    pub struct NoInit(pub DynStruct<RealAccountPropsSansInit>);
    #[automatically_derived]
    impl ::core::fmt::Debug for NoInit {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "NoInit", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NoInit {
        #[inline]
        fn clone(&self) -> NoInit {
            NoInit(::core::clone::Clone::clone(&self.0))
        }
    }
    impl IsDynProp for NoInit {
        type TYPE = DynStruct<RealAccountPropsSansInit>;
        const LABEL: &'static str = "noinit";
    }
    impl NoInit {
        pub fn unwrap(self) -> DynStruct<RealAccountPropsSansInit> {
            self.0
        }
    }
    pub enum ParseAccountProps {
        Boxed(Boxed),
        Space(Space),
        Constraints(Constraints),
        Mut(Mut),
        Seeds(Seeds),
        TokenMint(TokenMint),
        TokenAuthority(TokenAuthority),
        AccountType(AccountType),
        Depends(Depends),
        Init(Init),
        NoInit(NoInit),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ParseAccountProps {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ParseAccountProps::Boxed(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boxed",
                        &__self_0,
                    )
                }
                ParseAccountProps::Space(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Space",
                        &__self_0,
                    )
                }
                ParseAccountProps::Constraints(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Constraints",
                        &__self_0,
                    )
                }
                ParseAccountProps::Mut(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mut",
                        &__self_0,
                    )
                }
                ParseAccountProps::Seeds(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Seeds",
                        &__self_0,
                    )
                }
                ParseAccountProps::TokenMint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TokenMint",
                        &__self_0,
                    )
                }
                ParseAccountProps::TokenAuthority(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TokenAuthority",
                        &__self_0,
                    )
                }
                ParseAccountProps::AccountType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AccountType",
                        &__self_0,
                    )
                }
                ParseAccountProps::Depends(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Depends",
                        &__self_0,
                    )
                }
                ParseAccountProps::Init(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Init",
                        &__self_0,
                    )
                }
                ParseAccountProps::NoInit(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NoInit",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ParseAccountProps {
        #[inline]
        fn clone(&self) -> ParseAccountProps {
            match self {
                ParseAccountProps::Boxed(__self_0) => {
                    ParseAccountProps::Boxed(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::Space(__self_0) => {
                    ParseAccountProps::Space(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::Constraints(__self_0) => {
                    ParseAccountProps::Constraints(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::Mut(__self_0) => {
                    ParseAccountProps::Mut(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::Seeds(__self_0) => {
                    ParseAccountProps::Seeds(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::TokenMint(__self_0) => {
                    ParseAccountProps::TokenMint(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::TokenAuthority(__self_0) => {
                    ParseAccountProps::TokenAuthority(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                ParseAccountProps::AccountType(__self_0) => {
                    ParseAccountProps::AccountType(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::Depends(__self_0) => {
                    ParseAccountProps::Depends(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::Init(__self_0) => {
                    ParseAccountProps::Init(::core::clone::Clone::clone(__self_0))
                }
                ParseAccountProps::NoInit(__self_0) => {
                    ParseAccountProps::NoInit(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for Boxed {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::Boxed(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::Boxed(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for Space {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::Space(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::Space(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for Constraints {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::Constraints(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::Constraints(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for Mut {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::Mut(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::Mut(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for Seeds {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::Seeds(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::Seeds(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for TokenMint {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::TokenMint(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::TokenMint(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for TokenAuthority {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::TokenAuthority(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::TokenAuthority(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for AccountType {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::AccountType(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::AccountType(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for Depends {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::Depends(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::Depends(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for Init {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::Init(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::Init(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropOf<ParseAccountProps> for NoInit {
        fn downcast_ref(set: &ParseAccountProps) -> &Self {
            match set {
                ParseAccountProps::NoInit(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
        fn downcast(set: ParseAccountProps) -> Self {
            match set {
                ParseAccountProps::NoInit(o) => o,
                _ => {
                    ::core::panicking::panic_fmt(format_args!("downcast_ref failed"));
                }
            }
        }
    }
    impl PropSet for ParseAccountProps {
        const PROPS: &[&str] = &[
            Boxed::LABEL,
            Space::LABEL,
            Constraints::LABEL,
            Mut::LABEL,
            Seeds::LABEL,
            TokenMint::LABEL,
            TokenAuthority::LABEL,
            AccountType::LABEL,
            Depends::LABEL,
            Init::LABEL,
            NoInit::LABEL,
        ];
        fn has_prop(label: &str) -> bool {
            label == Boxed::LABEL || label == Space::LABEL || label == Constraints::LABEL
                || label == Mut::LABEL || label == Seeds::LABEL
                || label == TokenMint::LABEL || label == TokenAuthority::LABEL
                || label == AccountType::LABEL || label == Depends::LABEL
                || label == Init::LABEL || label == NoInit::LABEL
        }
        fn label(&self) -> &'static str {
            match self {
                ParseAccountProps::Boxed(_) => Boxed::LABEL,
                ParseAccountProps::Space(_) => Space::LABEL,
                ParseAccountProps::Constraints(_) => Constraints::LABEL,
                ParseAccountProps::Mut(_) => Mut::LABEL,
                ParseAccountProps::Seeds(_) => Seeds::LABEL,
                ParseAccountProps::TokenMint(_) => TokenMint::LABEL,
                ParseAccountProps::TokenAuthority(_) => TokenAuthority::LABEL,
                ParseAccountProps::AccountType(_) => AccountType::LABEL,
                ParseAccountProps::Depends(_) => Depends::LABEL,
                ParseAccountProps::Init(_) => Init::LABEL,
                ParseAccountProps::NoInit(_) => NoInit::LABEL,
            }
        }
    }
    impl Into<ParseAccountProps> for Boxed {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::Boxed(self)
        }
    }
    impl Into<ParseAccountProps> for Space {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::Space(self)
        }
    }
    impl Into<ParseAccountProps> for Constraints {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::Constraints(self)
        }
    }
    impl Into<ParseAccountProps> for Mut {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::Mut(self)
        }
    }
    impl Into<ParseAccountProps> for Seeds {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::Seeds(self)
        }
    }
    impl Into<ParseAccountProps> for TokenMint {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::TokenMint(self)
        }
    }
    impl Into<ParseAccountProps> for TokenAuthority {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::TokenAuthority(self)
        }
    }
    impl Into<ParseAccountProps> for AccountType {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::AccountType(self)
        }
    }
    impl Into<ParseAccountProps> for Depends {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::Depends(self)
        }
    }
    impl Into<ParseAccountProps> for Init {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::Init(self)
        }
    }
    impl Into<ParseAccountProps> for NoInit {
        fn into(self) -> ParseAccountProps {
            ParseAccountProps::NoInit(self)
        }
    }
    #[allow(unused_imports)]
    pub(crate) use impl_prop_dispatch_ParseAccountProps;
    pub enum ContextProp {
        Account { name: syn::Ident, args: Vec<syn::Ident> },
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContextProp {
        #[inline]
        fn clone(&self) -> ContextProp {
            match self {
                ContextProp::Account { name: __self_0, args: __self_1 } => {
                    ContextProp::Account {
                        name: ::core::clone::Clone::clone(__self_0),
                        args: ::core::clone::Clone::clone(__self_1),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContextProp {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContextProp::Account { name: __self_0, args: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Account",
                        "name",
                        __self_0,
                        "args",
                        &__self_1,
                    )
                }
            }
        }
    }
    pub struct KeyedVec<T>(pub Vec<(Ident, T)>);
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for KeyedVec<T> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "KeyedVec", &&self.0)
        }
    }
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for KeyedVec<T> {
        #[inline]
        fn default() -> KeyedVec<T> {
            KeyedVec(::core::default::Default::default())
        }
    }
    impl<T> KeyedVec<T> {
        pub fn new() -> Self {
            KeyedVec(::alloc::vec::Vec::new())
        }
        pub fn has(&self, id: &Ident) -> bool {
            self.iter().any(|(i, _)| i == id)
        }
        pub fn get(&self, id: &Ident) -> Option<&T> {
            self.iter().find_map(|(i, t)| (id == i).then_some(t))
        }
        pub fn insert(&mut self, id: Ident, val: T) -> Result<()> {
            if self.has(&id) {
                Err(
                    syn::Error::new(
                        id.span(),
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("KeyedVec insert already exists: {0}", id),
                            );
                            res
                        }),
                    ),
                )
            } else {
                Ok(self.0.push((id, val)))
            }
        }
        pub fn iter(&self) -> impl Iterator<Item = &(Ident, T)> {
            self.0.iter()
        }
    }
    impl<T> FromIterator<(Ident, T)> for KeyedVec<T> {
        fn from_iter<I: IntoIterator<Item = (Ident, T)>>(iter: I) -> Self {
            KeyedVec(Vec::from_iter(iter))
        }
    }
    impl<T> IntoIterator for KeyedVec<T> {
        type Item = (Ident, T);
        type IntoIter = std::vec::IntoIter<Self::Item>;
        fn into_iter(self) -> Self::IntoIter {
            self.0.into_iter()
        }
    }
    pub(crate) use parse_error;
    pub struct BuiltContexts(pub KeyedVec<BuiltContext>);
    #[automatically_derived]
    impl ::core::fmt::Debug for BuiltContexts {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "BuiltContexts",
                &&self.0,
            )
        }
    }
    pub struct BuiltContext(pub HashMap<Ident, BuiltAccount>);
    #[automatically_derived]
    impl ::core::fmt::Debug for BuiltContext {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "BuiltContext",
                &&self.0,
            )
        }
    }
    pub struct BuiltAccount(pub DynStruct<RealAccountProps>);
    #[automatically_derived]
    impl ::core::fmt::Debug for BuiltAccount {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "BuiltAccount",
                &&self.0,
            )
        }
    }
}
mod parse {
    use syn::spanned::Spanned;
    use syn::*;
    use crate::types::*;
    use crate::indented::*;
    use crate::propsets::*;
    impl parse::Parse for YamlDoc {
        fn parse(input: parse::ParseStream) -> Result<Self> {
            let mut accounts = KeyedVec::<DynStruct<ParseAccountProps>>::new();
            let mut contexts = KeyedVec::<Vec<ContextProp>>::default();
            while !input.is_empty() {
                input.parse::<Indent<0>>()?;
                let mut name = input.parse::<syn::Ident>()?;
                if name == "context" {
                    name = input.parse::<syn::Ident>()?;
                    input.parse::<::syn::token::Colon>()?;
                    let props = parse_at_level::<Indent<1>, ContextProp>(input)?;
                    contexts.insert(name, props)?;
                } else {
                    if accounts.has(&name) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("account exists: {0}", name),
                            );
                        };
                    }
                    let t = input.parse::<::syn::token::Colon>()?;
                    accounts.insert(name, parse_indented::<Indent<1>, _>(input)?)?;
                }
            }
            Ok(YamlDoc(YamlContexts(contexts), accounts))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for ContextProp {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            let id = input.parse::<syn::Ident>()?;
            input.parse::<::syn::token::Colon>()?;
            let content;
            match ::syn::__private::parse_brackets(&input) {
                ::syn::__private::Ok(brackets) => {
                    content = brackets.content;
                    brackets.token
                }
                ::syn::__private::Err(error) => {
                    return ::syn::__private::Err(error);
                }
            };
            let args = content
                .parse_terminated::<syn::Ident, ::syn::token::Comma>(|p| p.parse())?;
            let args = args.into_iter().collect();
            Ok(ContextProp::Account {
                name: id,
                args,
            })
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for Space {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(Space(parse_indented_token::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for Mut {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(Mut(parse_indented_token::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for Boxed {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(Boxed(parse_indented_token::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for Constraints {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(Constraints(parse_yaml_token_array::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for AccountType {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(AccountType(parse_indented_token::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for TokenMint {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(TokenMint(parse_indented_token::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for TokenAuthority {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(TokenAuthority(parse_indented_token::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for Depends {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(Depends(parse_yaml_token_array::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for Seeds {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(Seeds(parse_indented_token::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for Init {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(Init(parse_indented_next_level::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel> ParseIndented<L> for NoInit {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            Ok(NoInit(parse_indented_next_level::<L, _>(input)?))
        }
    }
    impl<L: IndentLevel, Set: DispatchParseIndented> ParseIndented<L>
    for DynStruct<Set> {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            let mut props = DynStruct::<Set>::new();
            parse_at_level_fn::<
                L,
            >(
                input,
                || {
                    let p = parse_indented::<L, _>(input)?;
                    props.insert_dyn(p);
                    Ok(())
                },
            )?;
            Ok(props)
        }
    }
    trait DispatchParseIndented: PropSet {
        fn dispatch<L: IndentLevel>(
            label: &str,
            input: parse::ParseStream,
        ) -> Result<Self>;
    }
    impl DispatchParseIndented for ParseAccountProps {
        fn dispatch<L: IndentLevel>(
            label: &str,
            input: parse::ParseStream,
        ) -> Result<Self> {
            if label == Boxed::LABEL {
                type T = Boxed;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == Space::LABEL {
                type T = Space;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == Constraints::LABEL {
                type T = Constraints;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == Mut::LABEL {
                type T = Mut;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == Seeds::LABEL {
                type T = Seeds;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == TokenMint::LABEL {
                type T = TokenMint;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == TokenAuthority::LABEL {
                type T = TokenAuthority;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == AccountType::LABEL {
                type T = AccountType;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == Depends::LABEL {
                type T = Depends;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == Init::LABEL {
                type T = Init;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else if label == NoInit::LABEL {
                type T = NoInit;
                { <T as ParseIndented<L>>::parse_indented(input).map(|s| s.into()) }
            } else {
                Err(syn::Error::new(input.span(), "invalid property"))
            }
        }
    }
    impl DispatchParseIndented for RealAccountPropsSansInit {
        fn dispatch<L: IndentLevel>(
            label: &str,
            input: parse::ParseStream,
        ) -> Result<Self> {
            if label == Boxed::LABEL {
                type T = Boxed;
                { <T as ParseIndented<L>>::parse_indented(input).map(|r| r.into()) }
            } else if label == Space::LABEL {
                type T = Space;
                { <T as ParseIndented<L>>::parse_indented(input).map(|r| r.into()) }
            } else if label == Constraints::LABEL {
                type T = Constraints;
                { <T as ParseIndented<L>>::parse_indented(input).map(|r| r.into()) }
            } else if label == Mut::LABEL {
                type T = Mut;
                { <T as ParseIndented<L>>::parse_indented(input).map(|r| r.into()) }
            } else if label == AccountType::LABEL {
                type T = AccountType;
                { <T as ParseIndented<L>>::parse_indented(input).map(|r| r.into()) }
            } else if label == Seeds::LABEL {
                type T = Seeds;
                { <T as ParseIndented<L>>::parse_indented(input).map(|r| r.into()) }
            } else if label == TokenMint::LABEL {
                type T = TokenMint;
                { <T as ParseIndented<L>>::parse_indented(input).map(|r| r.into()) }
            } else if label == TokenAuthority::LABEL {
                type T = TokenAuthority;
                { <T as ParseIndented<L>>::parse_indented(input).map(|r| r.into()) }
            } else {
                Err(syn::Error::new(input.span(), "invalid property"))
            }
        }
    }
    impl<L: IndentLevel, Set: DispatchParseIndented> ParseIndented<L> for Set {
        fn parse_indented(input: parse::ParseStream) -> Result<Self> {
            let PropLabel(span, label) = input.fork().parse()?;
            if !Set::has_prop(label) {
                {
                    ::std::io::_eprint(format_args!("{0:?}\n", Set::PROPS));
                };
                return Err(
                    syn::Error::new(
                        input.span(),
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("invalid property: {0}", label),
                            );
                            res
                        }),
                    ),
                );
            }
            let PropLabel(span, label) = input.parse()?;
            input.parse::<::syn::token::Colon>()?;
            <Set as DispatchParseIndented>::dispatch::<L>(label, input)
        }
    }
    struct PropLabel(proc_macro2::Span, &'static str);
    impl parse::Parse for PropLabel {
        fn parse(input: parse::ParseStream) -> Result<Self> {
            if input.peek(::syn::token::Type) {
                let t = input.parse::<::syn::token::Type>()?;
                Ok(PropLabel(t.span, "type"))
            } else if input.peek(::syn::token::Struct) {
                let t = input.parse::<::syn::token::Struct>()?;
                Ok(PropLabel(t.span, "struct"))
            } else if input.peek(::syn::token::Mut) {
                let t = input.parse::<::syn::token::Mut>()?;
                Ok(PropLabel(t.span, "mut"))
            } else {
                let path = input.parse::<syn::Path>()?;
                let s = {
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::ToTokens::to_tokens(&path, &mut _s);
                    _s
                }
                    .to_string();
                let s = Box::leak(s.to_owned().into_boxed_str());
                Ok(PropLabel(path.segments[0].span(), s))
            }
        }
    }
}
mod build {
    use std::collections::HashMap;
    use syn::*;
    use crate::{propsets::DynStruct, types::*};
    pub fn build_contexts(
        YamlDoc(YamlContexts(contexts), accounts): &YamlDoc,
    ) -> Result<BuiltContexts> {
        contexts
            .iter()
            .map(|(id, props)| {
                let props = build_context(props, accounts)?;
                Ok((id.clone(), props))
            })
            .collect::<Result<_>>()
            .map(BuiltContexts)
    }
    type ContextDependencies = HashMap<Ident, Vec<Ident>>;
    fn build_context(
        props: &Vec<ContextProp>,
        account_defs: &YamlAccounts,
    ) -> Result<BuiltContext> {
        let mut depends = props
            .iter()
            .cloned()
            .map(|ctx_prop| {
                match ctx_prop {
                    ContextProp::Account { name, args } => (name, args),
                }
            })
            .collect::<ContextDependencies>();
        let mut accts = HashMap::new();
        loop {
            let r = depends.clone().into_iter().find(|(k, _)| !accts.contains_key(k));
            if let Some((id, args)) = r {
                let account = account_defs
                    .get(&id)
                    .ok_or_else(|| syn::Error::new(id.span(), "undefined account"))?;
                accts.insert(id.clone(), build_account(account, args, &mut depends)?);
                continue;
            }
            break;
        };
        Ok(BuiltContext(accts))
    }
    fn build_account(
        account: &DynStruct<ParseAccountProps>,
        args: Vec<syn::Ident>,
        dependencies: &mut ContextDependencies,
    ) -> Result<BuiltAccount> {
        let mut out = DynStruct::<RealAccountProps>::new();
        let is_init = args.iter().any(|i| i == "init");
        let mut init_props = DynStruct::<RealAccountPropsSansInit>::new();
        account
            .iter()
            .for_each(|prop| {
                match prop.1 {
                    ParseAccountProps::Constraints(o) => {
                        out.insert(o);
                    }
                    ParseAccountProps::Mut(o) => {
                        out.insert(o);
                    }
                    ParseAccountProps::Seeds(o) => {
                        out.insert(o);
                    }
                    ParseAccountProps::TokenMint(o) => {
                        out.insert(o);
                    }
                    ParseAccountProps::TokenAuthority(o) => {
                        out.insert(o);
                    }
                    ParseAccountProps::AccountType(o) => {
                        out.insert(o);
                    }
                    ParseAccountProps::Boxed(o) => {
                        out.insert(o);
                    }
                    ParseAccountProps::Space(o) => {
                        out.insert(o);
                    }
                    ParseAccountProps::Init(o) => {
                        if is_init {
                            init_props = o.unwrap();
                        }
                    }
                    ParseAccountProps::NoInit(o) => {
                        if !is_init {
                            init_props = o.unwrap();
                        }
                    }
                    ParseAccountProps::Depends(o) => {
                        o.unwrap()
                            .into_iter()
                            .for_each(|d| {
                                dependencies.entry(d).or_insert(::alloc::vec::Vec::new());
                            });
                    }
                }
            });
        init_props
            .iter()
            .for_each(|prop| {
                match prop.1 {
                    RealAccountPropsSansInit::Boxed(o) => {
                        out.insert(o);
                    }
                    RealAccountPropsSansInit::Constraints(o) => {
                        out.insert(o);
                    }
                    RealAccountPropsSansInit::Mut(o) => {
                        out.insert(o);
                    }
                    RealAccountPropsSansInit::AccountType(o) => {
                        out.insert(o);
                    }
                    RealAccountPropsSansInit::Seeds(o) => {
                        out.insert(o);
                    }
                    RealAccountPropsSansInit::Space(o) => {
                        out.insert(o);
                    }
                    RealAccountPropsSansInit::TokenMint(o) => {
                        out.insert(o);
                    }
                    RealAccountPropsSansInit::TokenAuthority(o) => {
                        out.insert(o);
                    }
                }
            });
        if is_init {
            out.insert(RealInit(()));
        }
        Ok(BuiltAccount(out))
    }
}
mod compile {
    use crate::{propsets::DynStruct, types::*};
    use syn::*;
    use quote;
    pub fn compile(BuiltContexts(contexts): BuiltContexts) -> proc_macro2::TokenStream {
        let r = contexts.into_iter().map(compile_context).collect::<Vec<_>>();
        {
            let mut _s = ::quote::__private::TokenStream::new();
            {
                use ::quote::__private::ext::*;
                let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                #[allow(unused_mut)]
                let (mut r, i) = r.quote_into_iter();
                let has_iter = has_iter | i;
                let _: ::quote::__private::HasIterator = has_iter;
                while true {
                    let r = match r.next() {
                        Some(_x) => ::quote::__private::RepInterp(_x),
                        None => break,
                    };
                    ::quote::ToTokens::to_tokens(&r, &mut _s);
                }
            }
            _s
        }
    }
    fn compile_context(
        (name, BuiltContext(ctx)): (Ident, BuiltContext),
    ) -> proc_macro2::TokenStream {
        let accounts = ctx.into_iter().map(compile_account);
        {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::__private::push_pound(&mut _s);
            ::quote::__private::push_group(
                &mut _s,
                ::quote::__private::Delimiter::Bracket,
                {
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "derive");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "Accounts");
                            _s
                        },
                    );
                    _s
                },
            );
            ::quote::__private::push_ident(&mut _s, "struct");
            ::quote::ToTokens::to_tokens(&name, &mut _s);
            ::quote::__private::push_lt(&mut _s);
            ::quote::__private::push_lifetime(&mut _s, "\'info");
            ::quote::__private::push_gt(&mut _s);
            ::quote::__private::push_group(
                &mut _s,
                ::quote::__private::Delimiter::Brace,
                {
                    let mut _s = ::quote::__private::TokenStream::new();
                    {
                        use ::quote::__private::ext::*;
                        let mut _i = 0usize;
                        let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                        #[allow(unused_mut)]
                        let (mut accounts, i) = accounts.quote_into_iter();
                        let has_iter = has_iter | i;
                        let _: ::quote::__private::HasIterator = has_iter;
                        while true {
                            let accounts = match accounts.next() {
                                Some(_x) => ::quote::__private::RepInterp(_x),
                                None => break,
                            };
                            if _i > 0 {
                                ::quote::__private::push_comma(&mut _s);
                            }
                            _i += 1;
                            ::quote::ToTokens::to_tokens(&accounts, &mut _s);
                        }
                    }
                    _s
                },
            );
            _s
        }
    }
    fn compile_account(
        (name, BuiltAccount(props)): (Ident, BuiltAccount),
    ) -> proc_macro2::TokenStream {
        let metas = compile_metas(&props);
        let typ = compile_type(&props);
        {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::ToTokens::to_tokens(&metas, &mut _s);
            ::quote::__private::push_ident(&mut _s, "pub");
            ::quote::ToTokens::to_tokens(&name, &mut _s);
            ::quote::__private::push_colon(&mut _s);
            ::quote::ToTokens::to_tokens(&typ, &mut _s);
            _s
        }
    }
    fn compile_type(props: &DynStruct<RealAccountProps>) -> proc_macro2::TokenStream {
        let t = props.get::<AccountType>();
        {
            ::std::io::_eprint(format_args!("{0:?}\n", t));
        };
        match t {
            None => {
                ::core::panicking::panic_fmt(
                    format_args!("accountType or struct required"),
                );
            }
            Some(AccountType(ty)) => {
                let mut _s = ::quote::__private::TokenStream::new();
                ::quote::ToTokens::to_tokens(&ty, &mut _s);
                _s
            }
        }
    }
    fn compile_metas(props: &DynStruct<RealAccountProps>) -> proc_macro2::TokenStream {
        let pda = props.get::<Seeds>();
        if let Some(Seeds(seeds)) = pda {
            {
                let mut _s = ::quote::__private::TokenStream::new();
                ::quote::__private::push_pound(&mut _s);
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Bracket,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "account");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "seeds");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::ToTokens::to_tokens(&seeds, &mut _s);
                                ::quote::__private::push_comma(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "bump");
                                _s
                            },
                        );
                        _s
                    },
                );
                _s
            }
        } else {
            Default::default()
        }
    }
}
use build::build_contexts;
use indented::*;
use types::*;
use compile::compile;
#[proc_macro]
pub fn yaml_contexts(tokens: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let indented = create_indented_tokenstream(tokens);
    let doc = match ::syn::parse_macro_input::parse::<YamlDoc>(indented) {
        ::syn::__private::Ok(data) => data,
        ::syn::__private::Err(err) => {
            return ::syn::__private::TokenStream::from(err.to_compile_error());
        }
    };
    build_contexts(&doc)
        .map(compile)
        .unwrap_or_else(syn::Error::into_compile_error)
        .into()
}
const _: () = {
    extern crate proc_macro;
    #[rustc_proc_macro_decls]
    #[used]
    #[allow(deprecated)]
    static _DECLS: &[proc_macro::bridge::client::ProcMacro] = &[
        proc_macro::bridge::client::ProcMacro::bang("yaml_contexts", yaml_contexts),
    ];
};
