#![feature(prelude_import)]
#![allow(unexpected_cfgs)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
pub use anchor_lang::system_program::ID;
pub use anchor_spl::token::{TokenAccount, Mint};
use anchor_yaml_accounts::*;
use anchor_lang::prelude::*;
struct Thingy<'info> {
    #[account(constraint = quote_mint.freeze_authority.is_none())]
    pub quote_mint: Account<'info, Mint>,
    #[account(seeds = [b"system"], bump)]
    pub sys: Account<'info, CellSystem>,
    #[account(
        seeds = [b"cell_quote_reserve"],
        bump,
        token::mint = quote_mint,
        token::authority = sys
    )]
    pub cell_quote_reserve: Account<'info, TokenAccount>,
    #[account(seeds = [b"cell", cell.id.to_le_bytes().as_ref()], bump, mut)]
    pub cell: Box<Account<'info, Cell>>,
}
#[automatically_derived]
impl<'info> anchor_lang::Accounts<'info, ThingyBumps> for Thingy<'info>
where
    'info: 'info,
{
    #[inline(never)]
    fn try_accounts(
        __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
            'info,
        >],
        __ix_data: &[u8],
        __bumps: &mut ThingyBumps,
        __reallocs: &mut std::collections::BTreeSet<
            anchor_lang::solana_program::pubkey::Pubkey,
        >,
    ) -> anchor_lang::Result<Self> {
        let quote_mint: anchor_lang::accounts::account::Account<Mint> = anchor_lang::Accounts::try_accounts(
                __program_id,
                __accounts,
                __ix_data,
                __bumps,
                __reallocs,
            )
            .map_err(|e| e.with_account_name("quote_mint"))?;
        let sys: anchor_lang::accounts::account::Account<CellSystem> = anchor_lang::Accounts::try_accounts(
                __program_id,
                __accounts,
                __ix_data,
                __bumps,
                __reallocs,
            )
            .map_err(|e| e.with_account_name("sys"))?;
        let cell_quote_reserve: anchor_lang::accounts::account::Account<TokenAccount> = anchor_lang::Accounts::try_accounts(
                __program_id,
                __accounts,
                __ix_data,
                __bumps,
                __reallocs,
            )
            .map_err(|e| e.with_account_name("cell_quote_reserve"))?;
        let cell: Box<anchor_lang::accounts::account::Account<Cell>> = anchor_lang::Accounts::try_accounts(
                __program_id,
                __accounts,
                __ix_data,
                __bumps,
                __reallocs,
            )
            .map_err(|e| e.with_account_name("cell"))?;
        if !(quote_mint.freeze_authority.is_none()) {
            return Err(
                anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintRaw,
                    )
                    .with_account_name("quote_mint"),
            );
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[b"system"],
            &__program_id,
        );
        __bumps.sys = __bump;
        if sys.key() != __pda_address {
            return Err(
                anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                    )
                    .with_account_name("sys")
                    .with_pubkeys((sys.key(), __pda_address)),
            );
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[b"cell_quote_reserve"],
            &__program_id,
        );
        __bumps.cell_quote_reserve = __bump;
        if cell_quote_reserve.key() != __pda_address {
            return Err(
                anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                    )
                    .with_account_name("cell_quote_reserve")
                    .with_pubkeys((cell_quote_reserve.key(), __pda_address)),
            );
        }
        {
            if cell_quote_reserve.owner != sys.key() {
                return Err(anchor_lang::error::ErrorCode::ConstraintTokenOwner.into());
            }
            if cell_quote_reserve.mint != quote_mint.key() {
                return Err(anchor_lang::error::ErrorCode::ConstraintTokenMint.into());
            }
        }
        let (__pda_address, __bump) = Pubkey::find_program_address(
            &[b"cell", cell.id.to_le_bytes().as_ref()],
            &__program_id,
        );
        __bumps.cell = __bump;
        if cell.key() != __pda_address {
            return Err(
                anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintSeeds,
                    )
                    .with_account_name("cell")
                    .with_pubkeys((cell.key(), __pda_address)),
            );
        }
        if !AsRef::<AccountInfo>::as_ref(cell.as_ref()).is_writable {
            return Err(
                anchor_lang::error::Error::from(
                        anchor_lang::error::ErrorCode::ConstraintMut,
                    )
                    .with_account_name("cell"),
            );
        }
        Ok(Thingy {
            quote_mint,
            sys,
            cell_quote_reserve,
            cell,
        })
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountInfos<'info> for Thingy<'info>
where
    'info: 'info,
{
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        let mut account_infos = ::alloc::vec::Vec::new();
        account_infos.extend(self.quote_mint.to_account_infos());
        account_infos.extend(self.sys.to_account_infos());
        account_infos.extend(self.cell_quote_reserve.to_account_infos());
        account_infos.extend(self.cell.to_account_infos());
        account_infos
    }
}
#[automatically_derived]
impl<'info> anchor_lang::ToAccountMetas for Thingy<'info> {
    fn to_account_metas(
        &self,
        is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        let mut account_metas = ::alloc::vec::Vec::new();
        account_metas.extend(self.quote_mint.to_account_metas(None));
        account_metas.extend(self.sys.to_account_metas(None));
        account_metas.extend(self.cell_quote_reserve.to_account_metas(None));
        account_metas.extend(self.cell.to_account_metas(None));
        account_metas
    }
}
#[automatically_derived]
impl<'info> anchor_lang::AccountsExit<'info> for Thingy<'info>
where
    'info: 'info,
{
    fn exit(
        &self,
        program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        anchor_lang::AccountsExit::exit(&self.cell, program_id)
            .map_err(|e| e.with_account_name("cell"))?;
        Ok(())
    }
}
pub struct ThingyBumps {
    pub sys: u8,
    pub cell_quote_reserve: u8,
    pub cell: u8,
}
#[automatically_derived]
impl ::core::fmt::Debug for ThingyBumps {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "ThingyBumps",
            "sys",
            &self.sys,
            "cell_quote_reserve",
            &self.cell_quote_reserve,
            "cell",
            &&self.cell,
        )
    }
}
impl Default for ThingyBumps {
    fn default() -> Self {
        ThingyBumps {
            sys: u8::MAX,
            cell_quote_reserve: u8::MAX,
            cell: u8::MAX,
        }
    }
}
impl<'info> anchor_lang::Bumps for Thingy<'info>
where
    'info: 'info,
{
    type Bumps = ThingyBumps;
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a struct for a given
/// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
/// instead of an `AccountInfo`. This is useful for clients that want
/// to generate a list of accounts, without explicitly knowing the
/// order all the fields should be in.
///
/// To access the struct in this module, one should use the sibling
/// `accounts` module (also generated), which re-exports this.
pub(crate) mod __client_accounts_thingy {
    use super::*;
    use anchor_lang::prelude::borsh;
    /// Generated client accounts for [`Thingy`].
    pub struct Thingy {
        pub quote_mint: Pubkey,
        pub sys: Pubkey,
        pub cell_quote_reserve: Pubkey,
        pub cell: Pubkey,
    }
    impl borsh::ser::BorshSerialize for Thingy
    where
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.quote_mint, writer)?;
            borsh::BorshSerialize::serialize(&self.sys, writer)?;
            borsh::BorshSerialize::serialize(&self.cell_quote_reserve, writer)?;
            borsh::BorshSerialize::serialize(&self.cell, writer)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl anchor_lang::ToAccountMetas for Thingy {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas
                .push(
                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                        self.quote_mint,
                        false,
                    ),
                );
            account_metas
                .push(
                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                        self.sys,
                        false,
                    ),
                );
            account_metas
                .push(
                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                        self.cell_quote_reserve,
                        false,
                    ),
                );
            account_metas
                .push(
                    anchor_lang::solana_program::instruction::AccountMeta::new(
                        self.cell,
                        false,
                    ),
                );
            account_metas
        }
    }
}
/// An internal, Anchor generated module. This is used (as an
/// implementation detail), to generate a CPI struct for a given
/// `#[derive(Accounts)]` implementation, where each field is an
/// AccountInfo.
///
/// To access the struct in this module, one should use the sibling
/// [`cpi::accounts`] module (also generated), which re-exports this.
pub(crate) mod __cpi_client_accounts_thingy {
    use super::*;
    /// Generated CPI struct of the accounts for [`Thingy`].
    pub struct Thingy<'info> {
        pub quote_mint: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub sys: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        pub cell_quote_reserve: anchor_lang::solana_program::account_info::AccountInfo<
            'info,
        >,
        pub cell: anchor_lang::solana_program::account_info::AccountInfo<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for Thingy<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas
                .push(
                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                        anchor_lang::Key::key(&self.quote_mint),
                        false,
                    ),
                );
            account_metas
                .push(
                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                        anchor_lang::Key::key(&self.sys),
                        false,
                    ),
                );
            account_metas
                .push(
                    anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                        anchor_lang::Key::key(&self.cell_quote_reserve),
                        false,
                    ),
                );
            account_metas
                .push(
                    anchor_lang::solana_program::instruction::AccountMeta::new(
                        anchor_lang::Key::key(&self.cell),
                        false,
                    ),
                );
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for Thingy<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos
                .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.quote_mint));
            account_infos
                .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.sys));
            account_infos
                .extend(
                    anchor_lang::ToAccountInfos::to_account_infos(
                        &self.cell_quote_reserve,
                    ),
                );
            account_infos
                .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.cell));
            account_infos
        }
    }
}
struct Cell {
    id: u32,
}
impl borsh::ser::BorshSerialize for Cell
where
    u32: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.id, writer)?;
        Ok(())
    }
}
impl borsh::de::BorshDeserialize for Cell
where
    u32: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::maybestd::io::Read>(
        reader: &mut R,
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            id: borsh::BorshDeserialize::deserialize_reader(reader)?,
        })
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Cell {
    #[inline]
    fn clone(&self) -> Cell {
        Cell {
            id: ::core::clone::Clone::clone(&self.id),
        }
    }
}
#[automatically_derived]
impl anchor_lang::AccountSerialize for Cell {
    fn try_serialize<W: std::io::Write>(
        &self,
        writer: &mut W,
    ) -> anchor_lang::Result<()> {
        if writer.write_all(Cell::DISCRIMINATOR).is_err() {
            return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
        }
        if AnchorSerialize::serialize(self, writer).is_err() {
            return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
        }
        Ok(())
    }
}
#[automatically_derived]
impl anchor_lang::AccountDeserialize for Cell {
    fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
        if buf.len() < Cell::DISCRIMINATOR.len() {
            return Err(
                anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
            );
        }
        let given_disc = &buf[..Cell::DISCRIMINATOR.len()];
        if Cell::DISCRIMINATOR != given_disc {
            return Err(
                anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .name(),
                        error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .into(),
                        error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "src/lib.rs",
                                line: 55u32,
                            }),
                        ),
                        compared_values: None,
                    })
                    .with_account_name("Cell"),
            );
        }
        Self::try_deserialize_unchecked(buf)
    }
    fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
        let mut data: &[u8] = &buf[Cell::DISCRIMINATOR.len()..];
        AnchorDeserialize::deserialize(&mut data)
            .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
    }
}
#[automatically_derived]
impl anchor_lang::Discriminator for Cell {
    const DISCRIMINATOR: &'static [u8] = &[105, 32, 243, 35, 201, 39, 164, 138];
}
#[automatically_derived]
impl anchor_lang::Owner for Cell {
    fn owner() -> Pubkey {
        crate::ID
    }
}
struct CellSystem {
    a: bool,
}
impl borsh::ser::BorshSerialize for CellSystem
where
    bool: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.a, writer)?;
        Ok(())
    }
}
impl borsh::de::BorshDeserialize for CellSystem
where
    bool: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::maybestd::io::Read>(
        reader: &mut R,
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            a: borsh::BorshDeserialize::deserialize_reader(reader)?,
        })
    }
}
#[automatically_derived]
impl ::core::clone::Clone for CellSystem {
    #[inline]
    fn clone(&self) -> CellSystem {
        CellSystem {
            a: ::core::clone::Clone::clone(&self.a),
        }
    }
}
#[automatically_derived]
impl anchor_lang::AccountSerialize for CellSystem {
    fn try_serialize<W: std::io::Write>(
        &self,
        writer: &mut W,
    ) -> anchor_lang::Result<()> {
        if writer.write_all(CellSystem::DISCRIMINATOR).is_err() {
            return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
        }
        if AnchorSerialize::serialize(self, writer).is_err() {
            return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
        }
        Ok(())
    }
}
#[automatically_derived]
impl anchor_lang::AccountDeserialize for CellSystem {
    fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
        if buf.len() < CellSystem::DISCRIMINATOR.len() {
            return Err(
                anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound.into(),
            );
        }
        let given_disc = &buf[..CellSystem::DISCRIMINATOR.len()];
        if CellSystem::DISCRIMINATOR != given_disc {
            return Err(
                anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .name(),
                        error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .into(),
                        error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                            .to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "src/lib.rs",
                                line: 58u32,
                            }),
                        ),
                        compared_values: None,
                    })
                    .with_account_name("CellSystem"),
            );
        }
        Self::try_deserialize_unchecked(buf)
    }
    fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
        let mut data: &[u8] = &buf[CellSystem::DISCRIMINATOR.len()..];
        AnchorDeserialize::deserialize(&mut data)
            .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into())
    }
}
#[automatically_derived]
impl anchor_lang::Discriminator for CellSystem {
    const DISCRIMINATOR: &'static [u8] = &[102, 239, 92, 60, 229, 97, 95, 255];
}
#[automatically_derived]
impl anchor_lang::Owner for CellSystem {
    fn owner() -> Pubkey {
        crate::ID
    }
}
